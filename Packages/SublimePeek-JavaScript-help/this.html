<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>SublimePeek | Help for this</title><link href="css/bootstrap.min.css" rel="stylesheet"><style type="text/css">  body {  padding-top: 10px;  padding-bottom: 20px;  padding-left: 10%;  padding-right: 10%;  }  .sidebar-nav {  padding: 9px 0;  }</style><link href="css/bootstrap-responsive.min.css" rel="stylesheet"><link href="css/custom.css" rel="stylesheet">  </head><body><div style="display: block; "><div id="4eea835f8cd2963cba000002" class="page-header"><h2>this</h2><!--CONTENT--><div id = "section_1"><span id = "Introduction"></span><h2 class = "editable">Introduction</h2><p>A function's <code>this</code> keyword behaves a little differently in JavaScript compared to other languages. It also has some differences between <a title = "en/JavaScript/Strict mode" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a> and non-strict mode.</p><p>In general, the object bound to <code>this</code> in the current scope is determined by how the current function was called, it can't be set by assignment during execution, and it can be different each time the function is called. ES5 introduced the <code><a title = "en/JavaScript/Reference/Global_Objects/Function/bind" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">bind</a></code> method to <a title = "https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/this#Bound_functions" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Operators/this#Bound_functions">fix a function's <code>this</code> regardless of how it's called</a>.</p></div><div id = "section_2"><span id = "Global_context"></span><h2 class = "editable">Global context</h2><p>In the global context (outside of any function), <code>this</code> refers to the global object, whether in strict mode or not.</p><pre class = "eval">console.log(this.document === document); // true// In web browsers, the window object is also the global object:console.log(this === window); // truethis.a = 37;console.log(window.a); // 37</pre></div><div id = "section_3"><span id = "Function_context"></span><h2 class = "editable">Function context</h2><p>When the <code>this</code> keyword occurs inside a function, its value depends on how the function is called.</p><div id = "section_4"><span id = "Simple_call"></span><h3 class = "editable">Simple call</h3>          <pre name = "code" class = "js">function f1(){  return this;}f1() === window; // global objectfunction f2(){  &quot;use strict&quot;; // see strict mode  return this;}f2() === undefined;</pre>        <div class = "note"><strong>Note:</strong> In the second example, <code>this</code> should be <a title = "undefined" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>, because <code>f2</code> was called without providing any base (e.g. <code>window.f2()</code>). This feature wasn't implemented in some browsers when they first started to support <a title = "Strict mode" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a>; because of this, they incorrectly returned the <code>window</code> object.</div></div><div id = "section_5"><span id = "As_an_object_method"></span><h3 class = "editable">As an object method</h3><p>When a function is called as a method of an object, its <code>this</code> is set to the object the method is called on.</p><p>In the following example, when <code>o.f()</code> is invoked, inside the function <code>this</code> is bound to the <code>o</code> object.</p>          <pre name = "code" class = "js">var o = {  prop: 37,  f: function() {    return this.prop;  }};console.log(o.f()); // logs 37</pre>        <p>Note that this behavior is not at all affected by how or where the function was defined. In the previous example, we defined the function inline as the <code>f</code> member during the definition of <code>o</code>.&nbsp; However, we could have just as easily defined the function first and later attached it to <code>o.f</code>. Doing so results in the same behavior:</p>          <pre name = "code" class = "js">var o = {prop: 37};function independent() {  return this.prop;}o.f = independent;console.log(o.f()); // logs 37</pre>        <p>This demonstrates that it matters only that the function was invoked from the <code>f</code> member of <code>o</code>.</p><p>Similarly, the <code>this</code> binding is only affected by the most immediate member reference. In the following example, when we invoke the function, we call it as a method <code>g</code> of the object <code>o.b</code>. This time during execution, <code>this</code> inside the function will refer to <code>o.b</code>. The fact that the object is itself a member of <code>o</code> has no consequence; the most immediate reference is all that matters.</p>          <pre name = "code" class = "js">o.b = {g: independent, prop: 42};console.log(o.b.g()); // logs 42</pre>        <div id = "section_6"><span id = "..._on_the_prototype_chain"></span><h4 class = "editable">... on the prototype chain</h4><p>The same notion holds true for methods defined somewhere on the object's prototype chain. If the method is on an object's prototype chain, <code>this</code> refers to the object the method was called on, as if the method was on the object.</p>          <pre name = "code" class = "js">var o = {f:function(){ return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5</pre>        <p>In this example, the object assigned to the variable <code>p</code> doesn't have its own <code>f</code> property, it inherits it from its <a title = "Prototype" rel = "internal" href = "https://developer.mozilla.org/Prototype" class = "new ">prototype</a>. But it doesn't matter that the lookup for <code>f</code> eventually finds a member with that name on <code>o</code>; the lookup began as a reference to <code>p.f</code>, so <code>this</code> inside the function takes the value of the object referred to as <code>p</code>. That is, since <code>f</code> is called as a method of <code>p</code>, its <code>this</code> refers to <code>p</code>. This is an interesting feature of JavaScript's prototype inheritance.</p></div><div id = "section_7"><span id = "..._or_as_a_getter_or_setter"></span><h4 class = "editable">... or as a getter or setter</h4><p>Again, the same notion holds true when a function is invoked from a getter or a setter. A function used as getter or setter has its <code>this</code> bound to the object from which the property is being set or gotten.</p>          <pre name = "code" class = "js">function modulus(){  return Math.sqrt(this.re * this.re + this.im * this.im);}var o = {  re: 1,  im: -1,  get phase(){    return Math.atan2(this.im, this.re);  }};Object.defineProperty(o, 'modulus', {get: modulus, enumerable:true, configurable:true});console.log(o.phase, o.modulus); // logs -0.78 1.4142</pre>        </div></div><div id = "section_8"><span id = "As_a_constructor"></span><h3 class = "editable">As a constructor</h3><p>When a function is used as a constructor (with the <code><a title = "new" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Operators/new">new</a></code> keyword), its <code>this</code> is bound to new object being constructed, unless execution of the constructor results in the JavaScript engine encountering a return statement where the value to be returned is an object.</p>          <pre name = "code" class = "js">/* * Constructors work like this: * * function MyConstructor(){ *   // Actual function body code goes here.  Create properties on |this| as *   // desired by assigning to them.  E.g., *   this.fum = &quot;nom&quot;; *   // et cetera... * *   // If the function has a return statement that returns an object, that *   // object will be the result of the |new| expression.  Otherwise, the *   // result of the expression is the object currently bound to |this| *   // (i.e., the common case most usually seen). * } */function C(){  this.a = 37;}var o = new C();console.log(o.a); // logs 37function C2(){  this.a = 37;  return {a:38};}o = new C2();console.log(o.a); // logs 38</pre>        <p>In the last example (<code>C2</code>), because an object was returned during construction, the new object that <code>this</code> was bound to simply gets discarded. (This essentially makes the statement &quot;<code>this.a = 37;</code>&quot; dead code. It's not exactly dead, because it gets executed, but it can be eliminated with no outside effects.)</p></div><div id = "section_9"><span id = "call_and_apply"></span><h3 class = "editable"><code>call</code> and <code>apply</code></h3><p>Where a function uses the <code>this</code> keyword in its body, its value can be bound to a particular object during execution using the <code><a title = "en/JavaScript/Reference/Global_Objects/Function/call" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">call</a></code> or <code><a title = "en/JavaScript/Reference/Global_Objects/Function/apply" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">apply</a></code> methods that all functions inherit from <code>Function.prototype</code>.</p>          <pre name = "code" class = "js">function add(c, d){  return this.a + this.b + c + d;}var o = {a:1, b:3};// The first parameter is the object to use as 'this', subsequent parameters are passed as // arguments in the function calladd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// The first parameter is the object to use as 'this', the second is an array whose// members are used as the arguments in the function calladd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</pre>        </div><div id = "section_10"><span id = "Bound_functions"></span><h3 class = "editable">Bound functions</h3><p>ECMAScript 5 introduced <code><a title = "en/JavaScript/Reference/Global Objects/Function/bind" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a></code>. Calling <code>f.bind(someObject)</code> creates a new function with the same body and scope as <code>f</code>, but where <code>this</code> occurs in the original function, in the new function it is permanently bound to the first argument of <code>bind</code>, regardless of how the function is being used.</p>          <pre name = "code" class = "js">function f(){  return this.a;}var g = f.bind({a:&quot;azerty&quot;});console.log(g()); // azertyvar o = {a:37, f:f, g:g};console.log(o.f(), o.g()); // 37, azerty</pre>        </div><div id = "section_11"><span id = "As_a_DOM_event_handler"></span><h3 class = "editable">As a DOM event handler</h3><p>When a function is used as an event handler, its <code>this</code> is set to the element the event fired from (some browsers do not follow this convention for listeners added dynamically with methods other than <code>addEventListener</code>).</p>          <pre name = "code" class = "js">// When called as a listener, turns the related element bluefunction bluify(e){  console.log(this === e.currentTarget); // Always true  console.log(this === e.target);        // true when currentTarget and target are the same object  this.style.backgroundColor = '#A5D9F3';}// Get a list of every element in the documentvar elements = document.getElementsByTagName('*');// Add bluify as a click listener so when the element is clicked on,// it turns bluefor(var i=0 ; i&lt;elements.length ; i++){  elements[i].addEventListener('click', bluify, false);}</pre>        </div></div><div id = "section_4"><span id = "Simple_call"></span><h3 class = "editable">Simple call</h3>          <pre name = "code" class = "js">function f1(){  return this;}f1() === window; // global objectfunction f2(){  &quot;use strict&quot;; // see strict mode  return this;}f2() === undefined;</pre>        <div class = "note"><strong>Note:</strong> In the second example, <code>this</code> should be <a title = "undefined" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>, because <code>f2</code> was called without providing any base (e.g. <code>window.f2()</code>). This feature wasn't implemented in some browsers when they first started to support <a title = "Strict mode" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a>; because of this, they incorrectly returned the <code>window</code> object.</div></div><div id = "section_5"><span id = "As_an_object_method"></span><h3 class = "editable">As an object method</h3><p>When a function is called as a method of an object, its <code>this</code> is set to the object the method is called on.</p><p>In the following example, when <code>o.f()</code> is invoked, inside the function <code>this</code> is bound to the <code>o</code> object.</p>          <pre name = "code" class = "js">var o = {  prop: 37,  f: function() {    return this.prop;  }};console.log(o.f()); // logs 37</pre>        <p>Note that this behavior is not at all affected by how or where the function was defined. In the previous example, we defined the function inline as the <code>f</code> member during the definition of <code>o</code>.&nbsp; However, we could have just as easily defined the function first and later attached it to <code>o.f</code>. Doing so results in the same behavior:</p>          <pre name = "code" class = "js">var o = {prop: 37};function independent() {  return this.prop;}o.f = independent;console.log(o.f()); // logs 37</pre>        <p>This demonstrates that it matters only that the function was invoked from the <code>f</code> member of <code>o</code>.</p><p>Similarly, the <code>this</code> binding is only affected by the most immediate member reference. In the following example, when we invoke the function, we call it as a method <code>g</code> of the object <code>o.b</code>. This time during execution, <code>this</code> inside the function will refer to <code>o.b</code>. The fact that the object is itself a member of <code>o</code> has no consequence; the most immediate reference is all that matters.</p>          <pre name = "code" class = "js">o.b = {g: independent, prop: 42};console.log(o.b.g()); // logs 42</pre>        <div id = "section_6"><span id = "..._on_the_prototype_chain"></span><h4 class = "editable">... on the prototype chain</h4><p>The same notion holds true for methods defined somewhere on the object's prototype chain. If the method is on an object's prototype chain, <code>this</code> refers to the object the method was called on, as if the method was on the object.</p>          <pre name = "code" class = "js">var o = {f:function(){ return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5</pre>        <p>In this example, the object assigned to the variable <code>p</code> doesn't have its own <code>f</code> property, it inherits it from its <a title = "Prototype" rel = "internal" href = "https://developer.mozilla.org/Prototype" class = "new ">prototype</a>. But it doesn't matter that the lookup for <code>f</code> eventually finds a member with that name on <code>o</code>; the lookup began as a reference to <code>p.f</code>, so <code>this</code> inside the function takes the value of the object referred to as <code>p</code>. That is, since <code>f</code> is called as a method of <code>p</code>, its <code>this</code> refers to <code>p</code>. This is an interesting feature of JavaScript's prototype inheritance.</p></div><div id = "section_7"><span id = "..._or_as_a_getter_or_setter"></span><h4 class = "editable">... or as a getter or setter</h4><p>Again, the same notion holds true when a function is invoked from a getter or a setter. A function used as getter or setter has its <code>this</code> bound to the object from which the property is being set or gotten.</p>          <pre name = "code" class = "js">function modulus(){  return Math.sqrt(this.re * this.re + this.im * this.im);}var o = {  re: 1,  im: -1,  get phase(){    return Math.atan2(this.im, this.re);  }};Object.defineProperty(o, 'modulus', {get: modulus, enumerable:true, configurable:true});console.log(o.phase, o.modulus); // logs -0.78 1.4142</pre>        </div></div><div id = "section_6"><span id = "..._on_the_prototype_chain"></span><h4 class = "editable">... on the prototype chain</h4><p>The same notion holds true for methods defined somewhere on the object's prototype chain. If the method is on an object's prototype chain, <code>this</code> refers to the object the method was called on, as if the method was on the object.</p>          <pre name = "code" class = "js">var o = {f:function(){ return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5</pre>        <p>In this example, the object assigned to the variable <code>p</code> doesn't have its own <code>f</code> property, it inherits it from its <a title = "Prototype" rel = "internal" href = "https://developer.mozilla.org/Prototype" class = "new ">prototype</a>. But it doesn't matter that the lookup for <code>f</code> eventually finds a member with that name on <code>o</code>; the lookup began as a reference to <code>p.f</code>, so <code>this</code> inside the function takes the value of the object referred to as <code>p</code>. That is, since <code>f</code> is called as a method of <code>p</code>, its <code>this</code> refers to <code>p</code>. This is an interesting feature of JavaScript's prototype inheritance.</p></div><div id = "section_7"><span id = "..._or_as_a_getter_or_setter"></span><h4 class = "editable">... or as a getter or setter</h4><p>Again, the same notion holds true when a function is invoked from a getter or a setter. A function used as getter or setter has its <code>this</code> bound to the object from which the property is being set or gotten.</p>          <pre name = "code" class = "js">function modulus(){  return Math.sqrt(this.re * this.re + this.im * this.im);}var o = {  re: 1,  im: -1,  get phase(){    return Math.atan2(this.im, this.re);  }};Object.defineProperty(o, 'modulus', {get: modulus, enumerable:true, configurable:true});console.log(o.phase, o.modulus); // logs -0.78 1.4142</pre>        </div><div id = "section_8"><span id = "As_a_constructor"></span><h3 class = "editable">As a constructor</h3><p>When a function is used as a constructor (with the <code><a title = "new" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Operators/new">new</a></code> keyword), its <code>this</code> is bound to new object being constructed, unless execution of the constructor results in the JavaScript engine encountering a return statement where the value to be returned is an object.</p>          <pre name = "code" class = "js">/* * Constructors work like this: * * function MyConstructor(){ *   // Actual function body code goes here.  Create properties on |this| as *   // desired by assigning to them.  E.g., *   this.fum = &quot;nom&quot;; *   // et cetera... * *   // If the function has a return statement that returns an object, that *   // object will be the result of the |new| expression.  Otherwise, the *   // result of the expression is the object currently bound to |this| *   // (i.e., the common case most usually seen). * } */function C(){  this.a = 37;}var o = new C();console.log(o.a); // logs 37function C2(){  this.a = 37;  return {a:38};}o = new C2();console.log(o.a); // logs 38</pre>        <p>In the last example (<code>C2</code>), because an object was returned during construction, the new object that <code>this</code> was bound to simply gets discarded. (This essentially makes the statement &quot;<code>this.a = 37;</code>&quot; dead code. It's not exactly dead, because it gets executed, but it can be eliminated with no outside effects.)</p></div><div id = "section_9"><span id = "call_and_apply"></span><h3 class = "editable"><code>call</code> and <code>apply</code></h3><p>Where a function uses the <code>this</code> keyword in its body, its value can be bound to a particular object during execution using the <code><a title = "en/JavaScript/Reference/Global_Objects/Function/call" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">call</a></code> or <code><a title = "en/JavaScript/Reference/Global_Objects/Function/apply" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">apply</a></code> methods that all functions inherit from <code>Function.prototype</code>.</p>          <pre name = "code" class = "js">function add(c, d){  return this.a + this.b + c + d;}var o = {a:1, b:3};// The first parameter is the object to use as 'this', subsequent parameters are passed as // arguments in the function calladd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// The first parameter is the object to use as 'this', the second is an array whose// members are used as the arguments in the function calladd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</pre>        </div><div id = "section_10"><span id = "Bound_functions"></span><h3 class = "editable">Bound functions</h3><p>ECMAScript 5 introduced <code><a title = "en/JavaScript/Reference/Global Objects/Function/bind" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a></code>. Calling <code>f.bind(someObject)</code> creates a new function with the same body and scope as <code>f</code>, but where <code>this</code> occurs in the original function, in the new function it is permanently bound to the first argument of <code>bind</code>, regardless of how the function is being used.</p>          <pre name = "code" class = "js">function f(){  return this.a;}var g = f.bind({a:&quot;azerty&quot;});console.log(g()); // azertyvar o = {a:37, f:f, g:g};console.log(o.f(), o.g()); // 37, azerty</pre>        </div><div id = "section_11"><span id = "As_a_DOM_event_handler"></span><h3 class = "editable">As a DOM event handler</h3><p>When a function is used as an event handler, its <code>this</code> is set to the element the event fired from (some browsers do not follow this convention for listeners added dynamically with methods other than <code>addEventListener</code>).</p>          <pre name = "code" class = "js">// When called as a listener, turns the related element bluefunction bluify(e){  console.log(this === e.currentTarget); // Always true  console.log(this === e.target);        // true when currentTarget and target are the same object  this.style.backgroundColor = '#A5D9F3';}// Get a list of every element in the documentvar elements = document.getElementsByTagName('*');// Add bluify as a click listener so when the element is clicked on,// it turns bluefor(var i=0 ; i&lt;elements.length ; i++){  elements[i].addEventListener('click', bluify, false);}</pre>        </div><!--NOTE--><p class="source-link">This content was sourced by <a href="http://dochub.io/">DocHub</a> from MDN.</p></div></div></body></html>