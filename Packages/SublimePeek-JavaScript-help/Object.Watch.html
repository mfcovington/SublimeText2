<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>SublimePeek | Help for Object.watch</title><link href="css/bootstrap.min.css" rel="stylesheet"><style type="text/css">  body {  padding-top: 10px;  padding-bottom: 20px;  padding-left: 10%;  padding-right: 10%;  }  .sidebar-nav {  padding: 9px 0;  }</style><link href="css/bootstrap-responsive.min.css" rel="stylesheet"><link href="css/custom.css" rel="stylesheet">  </head><body><div style="display: block; "><div id="4eea835f8cd2963cba000002" class="page-header"><h2>Object.watch</h2><!--CONTENT--><div id = "section_1"><span id = "Summary"></span><h2 class = "editable">Summary</h2><p>Watches for a property to be assigned a value and runs a function when that occurs.</p><table class = "standard-table"> <thead> <tr> <th class = "header" colspan = "2">Method of <a title = "en/JavaScript/Reference/Global_Objects/Object" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></th> </tr> </thead> <tbody> <tr> <td>Implemented in</td> <td>JavaScript 1.8.6</td> </tr> <tr> <td>ECMAScript Edition</td> <td>none</td> </tr> </tbody></table></div><div id = "section_2"><span id = "Syntax"></span><h2 class = "editable">Syntax</h2><p><code><em>object</em>.watch(<em>prop</em>, <em>handler</em>) </code></p></div><div id = "section_3"><span id = "Parameters"></span><h2 class = "editable">Parameters</h2><dl> <dt><code>prop</code></dt> <dd>The name of a property of the object on which you wish to monitor changes.</dd></dl><dl> <dt><code>handler</code></dt> <dd>A function to call when the specified property's value changes.</dd></dl></div><div id = "section_4"><span id = "Description"></span><h2 class = "editable">Description</h2><div class = "warning"><strong>Warning:</strong> Generally you should avoid using <code>watch()</code> and <a title = "/en/JavaScript/Reference/Global_Objects/Object/unwatch" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/unwatch"><code>unwatch()</code></a> when possible. These two methods are implemented only in Gecko, and they're intended primarily for debugging use. In addition, using watchpoints has a serious negative impact on performance, which is especially true when used on global objects, such as window. You can usually use setters and getters or proxies instead. See <a rel = "custom" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/watch#Compatibility">Compatibility</a> for details.</div><p>Watches for assignment to a property named <code>prop</code> in this object, calling <code>handler(prop, oldval, newval)</code> whenever <code>prop</code> is set and storing the return value in that property. A watchpoint can filter (or nullify) the value assignment, by returning a modified <code>newval</code> (or by returning <code>oldval</code>).</p><p>If you delete a property for which a watchpoint has been set, that watchpoint does not disappear. If you later recreate the property, the watchpoint is still in effect.</p><p>To remove a watchpoint, use the <code><a title = "en/JavaScript/Reference/Global_Objects/Object/unwatch" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/unwatch">unwatch()</a></code> method. By default, the <code>watch</code> method is inherited by every object descended from <code>Object</code>.</p><p>The JavaScript debugger has functionality similar to that provided by this method, as well as other debugging options. For information on the debugger, see <a title = "en/Venkman" rel = "internal" href = "https://developer.mozilla.org/en/Venkman">Venkman</a>.</p><p>In Firefox, <code>handler</code> is only called from assignments in script, not from native code. For example, <code>window.watch('location', myHandler)</code> will not call <code>myHandler</code> if the user clicks a link to an anchor within the current document. However, <code>window.location += '#myAnchor'</code> will call <code>myHandler</code>.</p><div class = "note"><strong>Note:</strong> Calling <code>watch()</code> on an object for a specific property overrides and previous handler attached for that property.</div></div><div id = "section_5"><span id = "Examples"></span><h2 class = "editable">Examples</h2><div id = "section_6"><span id = "Example:_Using_watch_and_unwatch"></span><h3 class = "editable">Example: Using <code>watch</code> and <code>unwatch</code></h3>          <pre name = "code" class = "js">var o = {p:1};o.watch(&quot;p&quot;,  function (id, oldval, newval) {    console.log(&quot;o.&quot; + id + &quot; changed from &quot; + oldval + &quot; to &quot; + newval);    return newval;  });o.p = 2;o.p = 3;delete o.p;o.p = 4;o.unwatch('p');o.p = 5;</pre>        <p>This script displays the following:</p><pre class = "eval">o.p changed from 1 to 2o.p changed from 2 to 3o.p changed from undefined to 4</pre></div><div id = "section_7"><span id = "Example:_Using_watch_to_validate_an_object.27s_properties"></span><span id = "Example:_Using_watch_to_validate_an_object's_properties"></span><h3 class = "editable">Example: Using <code>watch</code> to validate an object's properties</h3><p>You can use <code>watch</code> to test any assignment to an object's properties. This example ensures that every Person always has a valid name and an age between 0 and 200.</p>          <pre name = "code" class = "js">Person = function(name,age) {  this.watch(&quot;age&quot;, Person.prototype._isValidAssignment);  this.watch(&quot;name&quot;, Person.prototype._isValidAssignment);  this.name = name;  this.age = age;}Person.prototype.toString = function() {  return this.name + &quot;, &quot; + this.age;};Person.prototype._isValidAssignment = function(id, oldval, newval) {  if (id === &quot;name&quot; &amp;&amp; (!newval || newval.length &gt; 30)) {    throw new RangeError(&quot;invalid name for &quot; + this);  }  if (id === &quot;age&quot;  &amp;&amp; (newval &lt; 0 || newval &gt; 200)) {    throw new RangeError(&quot;invalid age for &quot; + this);  }  return newval;}will = new Person(&quot;Will&quot;, 29);print(will);   // Will, 29try {  will.name = &quot;&quot;;} catch (e) {  print(e);}try {  will.age = -4;} catch (e) {  print(e);}</pre>        <p>This script displays the following:</p><pre class = "eval">Will, 29RangeError: invalid name for Will, 29RangeError: invalid age for Will, 29</pre></div></div><div id = "section_6"><span id = "Example:_Using_watch_and_unwatch"></span><h3 class = "editable">Example: Using <code>watch</code> and <code>unwatch</code></h3>          <pre name = "code" class = "js">var o = {p:1};o.watch(&quot;p&quot;,  function (id, oldval, newval) {    console.log(&quot;o.&quot; + id + &quot; changed from &quot; + oldval + &quot; to &quot; + newval);    return newval;  });o.p = 2;o.p = 3;delete o.p;o.p = 4;o.unwatch('p');o.p = 5;</pre>        <p>This script displays the following:</p><pre class = "eval">o.p changed from 1 to 2o.p changed from 2 to 3o.p changed from undefined to 4</pre></div><div id = "section_7"><span id = "Example:_Using_watch_to_validate_an_object.27s_properties"></span><span id = "Example:_Using_watch_to_validate_an_object's_properties"></span><h3 class = "editable">Example: Using <code>watch</code> to validate an object's properties</h3><p>You can use <code>watch</code> to test any assignment to an object's properties. This example ensures that every Person always has a valid name and an age between 0 and 200.</p>          <pre name = "code" class = "js">Person = function(name,age) {  this.watch(&quot;age&quot;, Person.prototype._isValidAssignment);  this.watch(&quot;name&quot;, Person.prototype._isValidAssignment);  this.name = name;  this.age = age;}Person.prototype.toString = function() {  return this.name + &quot;, &quot; + this.age;};Person.prototype._isValidAssignment = function(id, oldval, newval) {  if (id === &quot;name&quot; &amp;&amp; (!newval || newval.length &gt; 30)) {    throw new RangeError(&quot;invalid name for &quot; + this);  }  if (id === &quot;age&quot;  &amp;&amp; (newval &lt; 0 || newval &gt; 200)) {    throw new RangeError(&quot;invalid age for &quot; + this);  }  return newval;}will = new Person(&quot;Will&quot;, 29);print(will);   // Will, 29try {  will.name = &quot;&quot;;} catch (e) {  print(e);}try {  will.age = -4;} catch (e) {  print(e);}</pre>        <p>This script displays the following:</p><pre class = "eval">Will, 29RangeError: invalid name for Will, 29RangeError: invalid age for Will, 29</pre></div><div id = "section_8"><span id = "Compatibility"></span><h2 class = "editable">Compatibility</h2><ul> <li>This <span class = "external"><a class = "link-https" title = "https://gist.github.com/384583" rel = "external" href = "https://gist.github.com/384583" target = "_blank">Polyfill</a> that offers watch to all ES5 compatible browser</span></li> <li>Using a <a title = "Proxy" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> enables you do that even deeper changes to how property assignments work</li></ul></div><div id = "section_9"><span id = "See_Also"></span><span id = "See_also"></span><h2 class = "editable">See also</h2><p><a title = "en/JavaScript/Reference/Global_Objects/Object/unwatch" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/unwatch">unwatch()</a></p><p></p></div><!--NOTE--><p class="source-link">This content was sourced by <a href="http://dochub.io/">DocHub</a> from MDN.</p></div></div></body></html>