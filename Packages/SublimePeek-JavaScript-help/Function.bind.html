<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>SublimePeek | Help for Function.bind</title><link href="css/bootstrap.min.css" rel="stylesheet"><style type="text/css">  body {  padding-top: 10px;  padding-bottom: 20px;  padding-left: 10%;  padding-right: 10%;  }  .sidebar-nav {  padding: 9px 0;  }</style><link href="css/bootstrap-responsive.min.css" rel="stylesheet"><link href="css/custom.css" rel="stylesheet">  </head><body><div style="display: block; "><div id="4eea835f8cd2963cba000002" class="page-header"><h2>Function.bind</h2><!--CONTENT--><div id = "section_1"><span id = "Summary"></span><h2 class = "editable">Summary</h2><p>Creates a new function that, when called, itself calls this function in the context of the provided <code>this</code> value, with a given sequence of arguments preceding any provided when the new function was called.</p><table class = "standard-table"> <thead> <tr> <th class = "header" colspan = "2">Method of <a title = "en/JavaScript/Reference/Global_Objects/Function" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></th> </tr> </thead> <tbody> <tr> <td>Implemented in</td> <td>JavaScript 1.8.5</td> </tr> <tr> <td>ECMAScript Edition</td> <td>ECMAScript 5th Edition</td> </tr> </tbody></table></div><div id = "section_2"><span id = "Syntax"></span><h2 class = "editable">Syntax</h2><p><code><em>fun</em>.bind(<em>thisArg</em>[, <em>arg1</em>[, <em>arg2</em>[, ...]]])</code></p></div><div id = "section_3"><span id = "Parameters"></span><h2 class = "editable">Parameters</h2><dl> <dt>thisArg</dt> <dd>The value to be passed as the <code>this</code> parameter to the target function when the bound function is called. &nbsp;The value is ignored if the bound function is constructed using the <a title = "en/JavaScript/Reference/Operators/Special Operators/new Operator" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Operators/new"><code>new</code> operator</a>.</dd> <dt>arg1, arg2, ...</dt> <dd>Arguments to prepend to arguments provided to the bound function when invoking the target function.</dd></dl></div><div id = "section_4"><span id = "Description"></span><h2 class = "editable">Description</h2><p>The <code>bind</code> function creates a new function (a <em>bound function</em>) with the same function body (internal <a title = "Call" rel = "internal" href = "https://developer.mozilla.org/Call" class = "new ">Call</a> attribute in ECMAScript 5 terms) as the function it is being called on (the bound function's <em>target function</em>) with the <code>this</code> value bound to the first argument of <code>bind</code>, which cannot be overridden. <code>bind</code> also accepts leading default arguments to provide to the target function when the bound function is called. &nbsp;A bound function may also be constructed using the <code>new</code> operator: doing so acts as though the target function had instead been constructed. &nbsp;The provided <code>this</code> value is ignored, while prepended arguments are provided to the emulated function.</p></div><div id = "section_5"><span id = "Compatibility"></span><h2 class = "editable">Compatibility</h2><p>The <code>bind</code> function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of <code>bind</code> in implementations that do not natively support it.</p>          <pre name = "code" class = "js">if (!Function.prototype.bind) {  Function.prototype.bind = function (oThis) {    if (typeof this !== &quot;function&quot;) {      // closest thing possible to the ECMAScript 5 internal IsCallable function      throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);    }    var aArgs = Array.prototype.slice.call(arguments, 1),         fToBind = this,         fNOP = function () {},        fBound = function () {          return fToBind.apply(this instanceof fNOP                                 ? this                                 : oThis || window,                               aArgs.concat(Array.prototype.slice.call(arguments)));        };    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;  };}</pre>        <p>Some of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:</p><ul> <li>The partial implementation relies <code>Array.prototype.slice</code>, <code>Array.prototype.concat</code>, <code>Function.prototype.call</code> and <code>Function.prototype.apply</code>, built-in methods to have their original values.</li> <li>The partial implementation creates functions that do not have immutable &quot;poison pill&quot; <code>caller</code> and <code>arguments</code> properties that throw a <code>TypeError</code> upon get, set, or deletion. (This could be added if the implementation supports <a title = "en/JavaScript/Reference/Global Objects/Object/defineProperty" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>, or partially implemented [without throw-on-delete behavior] if the implementation supports the <a title = "en/JavaScript/Reference/Global Objects/Object/defineGetter" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineGetter"><code>__defineGetter__</code></a> and <a title = "en/JavaScript/Reference/Global Objects/Object/defineSetter" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineSetter"><code>__defineSetter__</code></a> extensions.)</li> <li>The partial implementation creates functions that have a <code>prototype</code> property. (Proper bound functions have none.)</li> <li>The partial implementation creates bound functions whose <code>length</code> property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.</li></ul><p>If you choose to use this partial implementation, <strong>you must not rely on those cases where behavior deviates from ECMA-262, 5th edition!</strong> With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when <code>bind</code> is widely implemented according to the specification.</p></div><div id = "section_6"><span id = "Examples"></span><h2 class = "editable">Examples</h2><div id = "section_7"><span id = "Creating_a_bound_function"></span><h3 class = "editable">Creating a bound function</h3><p>The simplest use of <code>bind</code> is to make a function that, no matter how it is called, is called with a particular <code>this</code> value. &nbsp;A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its <code>this</code> (e.g. by using that method in callback-based code). &nbsp;Without special care, however, the original object is usually lost. &nbsp;Creating a bound function from the function, using the original object, neatly solves this problem:</p>          <pre name = "code" class = "js">var x = 9; var module = {  x: 81,  getX: function() { return this.x; }};module.getX(); // 81var getX = module.getX;getX(); // 9, because in this case, &quot;this&quot; refers to the global object// create a new function with 'this' bound to modulevar boundGetX = getX.bind(module);boundGetX(); // 81</pre>        </div><div id = "section_8"><span id = "Currying"></span><h3 class = "editable">Currying</h3><p>The next simplest use of <code>bind</code> is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided <code>this</code> value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.</p>          <pre name = "code" class = "js">function list() {  return Array.prototype.slice.call(arguments);}var list1 = list(1, 2, 3); // [1, 2, 3]//  Create a function with a preset leading argumentvar leadingZeroList = list.bind(undefined, 37);var list2 = leadingZeroList(); // [37]var list3 = leadingZeroList(1, 2, 3); // [37, 1, 2, 3]</pre>        </div><div id = "section_9"><span id = "Bound_functions_used_as_constructors"></span><h3 class = "editable">Bound functions used as constructors</h3><p>Bound functions are automatically suitable for use with the <code>new</code> operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided <code>this</code> is ignored. However, provided arguments are still prepended to the constructor call:</p>          <pre name = "code" class = "js">function Point(x, y) {  this.x = x;  this.y = y;}Point.prototype.toString = function() {   return this.x + &quot;,&quot; + this.y; };var p = new Point(1, 2);p.toString(); // &quot;1,2&quot;var emptyObj = {};var YAxisPoint = Point.bind(emptyObj, 0 /* x */);var axisPoint = new YAxisPoint(5);axisPoint.toString(); //  &quot;0,5&quot;axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew Point(17, 42) instanceof YAxisPoint; // false with native bind // true, when using the above polyfill</pre>        <p>Note that you need do nothing special to create a bound function for use with <code>new</code>. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using <code>new</code>. If you wish to support use of a bound function only using <code>new</code>, or only by calling it, the target function must enforce that restriction.</p>          <pre name = "code" class = "js">// Example can be run directly in your JavaScript console// ...continuing from above// Can still be called as a normal function (although usually this is undesired)YAxisPoint(13);emptyObj.x + &quot;,&quot; + emptyObj.y;// &gt;  &quot;0,13&quot;</pre>        </div><div id = "section_10"><span id = "Supplemental"></span><span id = "Creating_Shortcuts"></span><h3 class = "editable"><span style = "font-size: 20px; line-height: 27px; ">Creating Shortcuts</span></h3><div> <p><code>bind</code>&nbsp;is also helpful in cases where you want to create a shortcut to a function which requires a specific <code>this</code> value.</p> <p>Take&nbsp;<code>Array.prototype.slice</code>, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:</p> <pre>var slice = Array.prototype.slice;// ...slice.call(arguments);</pre> <p>With&nbsp;<code>bind</code>, this can be simplified to the following. <code>slice</code> will be a bound function to the <code>.call</code> function of <code>Function.prototype</code>, with the <code>this </code>value set to the <code>.slice</code> function of <code>Array.prototype</code>. This means that additional <code>.call</code> calls can be eliminated:</p> <pre>var slice = Function.prototype.call.bind(Array.prototype.slice);// ...slice(arguments);</pre></div></div></div><div id = "section_7"><span id = "Creating_a_bound_function"></span><h3 class = "editable">Creating a bound function</h3><p>The simplest use of <code>bind</code> is to make a function that, no matter how it is called, is called with a particular <code>this</code> value. &nbsp;A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its <code>this</code> (e.g. by using that method in callback-based code). &nbsp;Without special care, however, the original object is usually lost. &nbsp;Creating a bound function from the function, using the original object, neatly solves this problem:</p>          <pre name = "code" class = "js">var x = 9; var module = {  x: 81,  getX: function() { return this.x; }};module.getX(); // 81var getX = module.getX;getX(); // 9, because in this case, &quot;this&quot; refers to the global object// create a new function with 'this' bound to modulevar boundGetX = getX.bind(module);boundGetX(); // 81</pre>        </div><div id = "section_8"><span id = "Currying"></span><h3 class = "editable">Currying</h3><p>The next simplest use of <code>bind</code> is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided <code>this</code> value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.</p>          <pre name = "code" class = "js">function list() {  return Array.prototype.slice.call(arguments);}var list1 = list(1, 2, 3); // [1, 2, 3]//  Create a function with a preset leading argumentvar leadingZeroList = list.bind(undefined, 37);var list2 = leadingZeroList(); // [37]var list3 = leadingZeroList(1, 2, 3); // [37, 1, 2, 3]</pre>        </div><div id = "section_9"><span id = "Bound_functions_used_as_constructors"></span><h3 class = "editable">Bound functions used as constructors</h3><p>Bound functions are automatically suitable for use with the <code>new</code> operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided <code>this</code> is ignored. However, provided arguments are still prepended to the constructor call:</p>          <pre name = "code" class = "js">function Point(x, y) {  this.x = x;  this.y = y;}Point.prototype.toString = function() {   return this.x + &quot;,&quot; + this.y; };var p = new Point(1, 2);p.toString(); // &quot;1,2&quot;var emptyObj = {};var YAxisPoint = Point.bind(emptyObj, 0 /* x */);var axisPoint = new YAxisPoint(5);axisPoint.toString(); //  &quot;0,5&quot;axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew Point(17, 42) instanceof YAxisPoint; // false with native bind // true, when using the above polyfill</pre>        <p>Note that you need do nothing special to create a bound function for use with <code>new</code>. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using <code>new</code>. If you wish to support use of a bound function only using <code>new</code>, or only by calling it, the target function must enforce that restriction.</p>          <pre name = "code" class = "js">// Example can be run directly in your JavaScript console// ...continuing from above// Can still be called as a normal function (although usually this is undesired)YAxisPoint(13);emptyObj.x + &quot;,&quot; + emptyObj.y;// &gt;  &quot;0,13&quot;</pre>        </div><div id = "section_10"><span id = "Supplemental"></span><span id = "Creating_Shortcuts"></span><h3 class = "editable"><span style = "font-size: 20px; line-height: 27px; ">Creating Shortcuts</span></h3><div> <p><code>bind</code>&nbsp;is also helpful in cases where you want to create a shortcut to a function which requires a specific <code>this</code> value.</p> <p>Take&nbsp;<code>Array.prototype.slice</code>, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:</p> <pre>var slice = Array.prototype.slice;// ...slice.call(arguments);</pre> <p>With&nbsp;<code>bind</code>, this can be simplified to the following. <code>slice</code> will be a bound function to the <code>.call</code> function of <code>Function.prototype</code>, with the <code>this </code>value set to the <code>.slice</code> function of <code>Array.prototype</code>. This means that additional <code>.call</code> calls can be eliminated:</p> <pre>var slice = Function.prototype.call.bind(Array.prototype.slice);// ...slice(arguments);</pre></div></div><div id = "section_11"><span id = "Supplemental"></span><h2 class = "editable">Supplemental</h2><p>One interesting wrinkle of bound functions working &quot;as expected&quot; with the <code>new</code> operator is that it is now possible to implement what one might call &quot;<code>Function.prototype.construct</code>&quot;, an analog to <code><a title = "en/JavaScript/Reference/Global Objects/Function/apply" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function.prototype.apply</a></code> that takes an array of values as its sole argument,&nbsp;constructing this function with the provided arguments using the <code>new</code> operator:</p>          <pre name = "code" class = "js">// Function.prototype.construct will work with the Function.prototype.bind defined aboveif (!Function.prototype.construct) {   Function.prototype.construct = function(aArgs) {    if (aArgs.constructor !== Array)      throw new TypeError(&quot;second argument to Function.prototype.construct must be an array&quot;);    var aBoundArgs = Array.prototype.concat.apply([null], aArgs),         fBound = this.bind.apply(this, aBoundArgs);            return new fBound();  };}// Now consider the string &quot;2011-7-16 19:35:46&quot;. Without an analog of the Function.apply method for constructors,// you would run a lot of steps in order to construct a Date object from it:var aDateArgs = &quot;2011-7-16 19:35:46&quot;.split(/[- :]/),    oMyDate1 = new Date(aDateArgs[0], aDateArgs[1], aDateArgs[2], aDateArgs[3], aDateArgs[4], aDateArgs[5]);alert(oMyDate1.toLocaleString());// With the Function.construct method we could do the same thing with a single step:var oMyDate2 = Date.construct(&quot;2011-7-16 19:35:46&quot;.split(/[- :]/));alert(oMyDate2.toLocaleString());// Here is another example:function Point(x, y) {  this.x = x;  this.y = y;}Point.prototype.toString = function() {   return this.x + &quot;,&quot; + this.y; };alert(Point.construct([2, 4]).toString()); // &quot;2,4&quot;</pre>        <p>But note well: the efficiency of constructing a new function every time you wish to construct an object by invoking a bound function via <code>new</code> with a variable number of arguments is questionable. Your code will be faster and more efficient if you use <code>Function.prototype.apply</code> instead, with normal call syntax rather than using <code>new</code> operator-based syntax.</p></div><div id = "section_12"><span id = "Browser_compatibility"></span><h2 class = "editable">Browser compatibility</h2><p><div class = "htab"><a name = "AutoCompatibilityTable"></a><ul> <li class = "selected">Desktop</li> <li>Mobile</li></ul></div></p><div id = "compat-desktop"> <table class = "compat-table"> <tbody> <tr> <th>Feature</th> <th>Firefox (Gecko)</th> <th>Chrome</th> <th>Internet Explorer</th> <th>Opera</th> <th>Safari</th> </tr> <tr> <td>Basic support</td> <td>4</td> <td>7</td> <td>9</td> <td>11.60</td> <td><span style = "color: rgb(255, 0, 0);" title = "Not supported.">--</span></td> </tr> </tbody> </table></div><div id = "compat-mobile"> <table class = "compat-table"> <tbody> <tr> <th>Feature</th> <th>Firefox Mobile (Gecko)</th> <th>Android</th> <th>IE Mobile</th> <th>Opera Mobile</th> <th>Safari Mobile</th> </tr> <tr> <td>Basic support</td> <td><span title = "Compatibility unknown; please update this." style = "color: rgb(255, 153, 0);">?</span></td> <td><span title = "Compatibility unknown; please update this." style = "color: rgb(255, 153, 0);">?</span></td> <td><span title = "Compatibility unknown; please update this." style = "color: rgb(255, 153, 0);">?</span></td> <td><span title = "Compatibility unknown; please update this." style = "color: rgb(255, 153, 0);">?</span></td> <td><span title = "Compatibility unknown; please update this." style = "color: rgb(255, 153, 0);">?</span></td> </tr> </tbody> </table></div><p>Based on <a class = "external" rel = "external" href = "http://kangax.github.com/es5-compat-table/" title = "http://kangax.github.com/es5-compat-table/" target = "_blank">Kangax's compat tables</a>.</p></div><div id = "section_13"><span id = "See_also"></span><h2 class = "editable">See also</h2><ul> <li><code><a title = "en/JavaScript/Reference/Global Objects/Function/apply" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function.prototype.apply</a></code></li> <li><code><a title = "en/JavaScript/Reference/Global Objects/Function/call" rel = "internal" href = "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call</a></code></li></ul></div><!--NOTE--><p class="source-link">This content was sourced by <a href="http://dochub.io/">DocHub</a> from MDN.</p></div></div></body></html>